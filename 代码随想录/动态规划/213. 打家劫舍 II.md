# 213 : 打家劫舍 II
来源：[力扣（LeetCode)](https://leetcode.cn/problems/house-robber-ii/)

* 难度：中等

## 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。


## 样例：
##### 示例 1：
```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```
##### 示例 2：
```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
**提示：**
* `1 <= nums.length <= 100`
* `0 <= nums[i] <= 1000`
  
## 思路
这道题跟打家劫舍几乎一样，只是多了一个“围成圈”的条件，回忆一下打家劫舍的做法，有两个状态数组，其中：
* f(i): 选择第i个点的情况下前i个点的最大和
* g(i): 不选择第i个点的情况下前i个点的最大和
则有：
* `f[i] = g[i - 1] + w[i]`;
* `g[i] = max(f[i - 1], g[i - 1])`;

这道题相比来说只是多了一个起点和终点的限制，即起点和终点不能同时选，其余都是一样的情况，因此只需要枚举以下情况：
1. 不选起点的情况，这种情况下终点可以选也可以不选。`max(f(n), g(n))`
2. 选择起点的情况，这种情况下终点不能选。`g(n)`

最后选择两种情况的最大值即可。
## 代码
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n + 1), g(n + 1);
        if (n == 1) return nums[0];
        //不选择起点的方案，从2号点开始枚举
        for (int i = 2; i <= n; i ++) {
            f[i] = g[i - 1] + nums[i - 1];
            g[i] = max(f[i - 1], g[i - 1]);
        }
        int res = max(f[n], g[n]);
        //选择起点的情况
        f[1] = nums[0];
        g[1] = INT_MIN;
         for (int i = 2; i <= n; i ++) {
            f[i] = g[i - 1] + nums[i - 1];
            g[i] = max(f[i - 1], g[i - 1]);
        }
        return max(res, g[n]);
    }
};
```