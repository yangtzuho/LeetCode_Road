# 300：最长递增子序列
来源：[力扣（LeetCode)](https://leetcode.cn/problems/longest-increasing-subsequence/)

* 难度：中等

## 题目描述
给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

## 样例：
##### 示例 1：
```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```
##### 示例 2：
```
输入：nums = [0,1,0,3,2,3]
输出：4
```
##### 示例 3：
```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**
* `1 <= nums.length <= 2500`
* `-10000 <= nums[i] <= 10000`

**进阶**：

你能将算法的时间复杂度降低到 `O(n log(n))` 吗?
## 思路
求以每个元素结尾的最长上升子序列的长度，当求以`a[i]`结尾的上升子序列的长度时，观察前i-1个数，找出长度为1的上升子序列的结尾的最小值，长度是2的上升子序列结尾的最小值...以此类推。
直觉上讲，长度越长，结尾最大，用**反证法**进行证明
* 单调性：反证法：加入长度是3的上升子序列结尾的最小值大于等于长度是4的上升子序列结尾的最小值，由于长度为4的上升子序列的前三个数构成了长度为3的上升子序列，且结尾值一定更小，故推导出矛盾，因此单调性得证。
* 如果以`a[i]`结尾长度是k的上升子序列存在的话，只要看前i-1个数中长度为k-1的上升子序列的结尾的最小值是否小于`a[i]`即可；
* 因此要找到**最大的长度**，使得在这个最大的长度下，结尾的最小值小于`a[i]`。
## 代码
* 动态规划解法，时间复杂度`O(n * n)`
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n + 1, 1);
        int res = 0;
        f[0] = 0;
        for (int i = 1; i <= n; i ++){
            for (int j = 1; j < i; j ++) {
                if (nums[i - 1] > nums[j - 1]) {
                    f[i] = max(f[i], f[j] + 1);
                }
            }
            res = max(res, f[i]);
        }
        return res;
    }
};
```

* 贪心 + 二分解法，时间复杂度`O(n log(n))`
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> q;
        
        //从前往后枚举每个元素
        for (auto x : nums) {
            //如果当前的x比q里的最后一个元素大
            //那么x可以接到最长的序列后面
            if (q.empty() || x > q.back()) q.push_back(x);
            else {
                //如果x比前面的所有数都要小或者相等
                if (x <= q[0]) q[0] = x;
                else {//找到小于x的最后一个元素
                    int l = 0, r = q.size() - 1;
                    while (l < r) {
                        int mid = l + r + 1>> 1;
                        if (q[mid] < x) l = mid;
                        else r = mid - 1;
                    }
                    q[r + 1] = x;
                }
            }
        }
        return q.size();
    }
};

```