# 516：最长回文子序列
来源：[力扣（LeetCode)](https://leetcode.cn/problems/longest-palindromic-subsequence/)

* 难度：中等

## 题目描述
给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

## 样例：
##### 示例 1：
```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```
##### 示例 2：
```
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```

**提示：**
* `1 <= s.length <= 1000`
* `s` 仅由小写英文字母组成
  
## 思路
**动态规划**
* 状态表示
`f[i, j]`: 表示区间`[i, j]`区间中最长回文子序列的长度。
* 状态计算
  * 以`i`, `j`这两个端点是否再回文子序列中进行分类，可以分为4类：`i,j`都在，`i`在`j`不在，`i`不在`j`在，`i, j`都不在。
  * 第一种情况，`i, j`都在，那么就要使得在区间`[i + 1, j - 1]`范围内最长，即这种情况下,`f[i, j] = f[i + 1, j - 1] + 2`
  * 第四种情况，`i, j`不在，这种情况下`f[i, j] = f[i + 1, j - 1]`， 这种情况在第二。三种情况中被包含。
  * 第二种情况则不能简单的用`f[i - 1, j]`表示，因为`f[i - 1, j]`不一定包含`i`，但是`f[i - 1][j]`是包含了第二种情况的
  * 同理`f[i + 1, j]`是包含了第三种情况的。


## 代码
```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> f(n, vector<int>(n));

        //区间DP枚举的顺序一般是固定的，先枚举查长度，再枚举左端点
        for (int len = 1; len <= n; len ++)
            for (int i = 0; i + len - 1 < n; i ++) {
                int j = i + len - 1; //右端点
                if (len == 1) f[i][j] = 1;
                else  {
                    if (s[i] == s[j]) f[i][j] = f[i + 1][j - 1] + 2;
                    f[i][j] = max(f[i][j], max(f[i + 1][j], f[i][j - 1]));
                }
            }
        return f[0][n - 1];
    }
};
```