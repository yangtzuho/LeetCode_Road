# 37：解数独
来源：[力扣（LeetCode)](https://leetcode.cn/problems/sudoku-solver/)

* 难度：困难
* 分类：`棋盘问题`

## 题目描述
编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

## 样例：
##### 示例1
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)
```
输入：board = 
[["5","3",".",".","7",".",".",".","."],
["6",".",".","1","9","5",".",".","."],
[".","9","8",".",".",".",".","6","."],
["8",".",".",".","6",".",".",".","3"],
["4",".",".","8",".","3",".",".","1"],
["7",".",".",".","2",".",".",".","6"],
[".","6",".",".",".",".","2","8","."],
[".",".",".","4","1","9",".",".","5"],
[".",".",".",".","8",".",".","7","9"]]

输出：
[["5","3","4","6","7","8","9","1","2"],
["6","7","2","1","9","5","3","4","8"],
["1","9","8","3","4","2","5","6","7"],
["8","5","9","7","6","1","4","2","3"],
["4","2","6","8","5","3","7","9","1"],
["7","1","3","9","2","4","8","5","6"],
["9","6","1","5","3","7","2","8","4"],
["2","8","7","4","1","9","6","3","5"],
["3","4","5","2","8","6","1","7","9"]]

解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png)

**提示：**
* board.length == 9
* board[i].length == 9
* board[i][j] 是一位数字或者 '.'
* 题目数据保证输入数独仅有一个解

## 思路
数独问题的搜索与N皇后问题类似，N皇后问题是按照行的顺序进行搜索，数独按照空格进行搜索，依次枚举空格填哪个数字。dfs中的参数有：
* 坐标(x, y): 当前枚举到了哪个格子
* 当前方案
* 三个bool状态数组：col[a][b]=true表示第a行已经填过b了,row[9][9]，cell[3][3][9];

## 代码
```c++
class Solution {
public:
    //分别表示每一行，每一列，每一个小方阵1-9是否出现过
    bool row[9][9], col[9][9], cell[3][3][9];

    void solveSudoku(vector<vector<char>>& board) {
        //先进行清空
        memset(row, 0, sizeof row);
        memset(col, 0, sizeof col);
        memset(cell, 0, sizeof cell);

        //先遍历一遍棋盘，把已经填进去的数更新到状态数组中
        for (int i = 0; i < 9; i ++)
            for (int j = 0; j < 9; j ++)
            if (board[i][j] != '.') {
                int t = board[i][j] - '1';
                row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true;
            }
        dfs(board, 0, 0);
    }

    bool dfs(vector<vector<char>>& board, int x, int y) {
        //先移动纵坐标，如果y已经越界，则走到下一行
        if (y == 9) x ++, y = 0;
        if (x == 9) return true;

        //如果当前位置已经有数了，则从下一个位置开始填
        if (board[x][y] != '.') return dfs(board, x, y + 1);

        //当前位置没有填数，枚举当前位置可以填哪些数
        for (int i = 0; i < 9; i ++)
            if (!row[x][i] && !col[y][i] && !cell[x / 3][y / 3][i]) {
                board[x][y] = i + '1';
                row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true;
                if (dfs(board, x, y + 1)) return true;
                //恢复现场
                row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false;
                board[x][y] = '.';
            }
        return false;
    }
};
```