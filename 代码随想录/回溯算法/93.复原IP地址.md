# 93：复原IP地址
来源：[力扣（LeetCode)](https://leetcode-cn.com/problems/restore-ip-addresses/)

* 难度：中等
* 分类：`分割`

## 题目描述
**有效 IP 地址**正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你**不能**重新排序或删除 s 中的任何数字。你可以按**任何**顺序返回答案。

## 样例：
##### 示例 1：
```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```
##### 示例 2：
```
输入：s = "0000"
输出：["0.0.0.0"]
```
##### 示例 3：
```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.
```
**提示：**
* 1 <= s.length <= 20
* s 仅由数字组成
## 思路
从前往后进行暴搜，搜的时候要确保每个点都在0-255之间且不能有前导0。dfs函数的参数意义
* string s 传入的字符串
* 枚举到的字符串的位数
* 枚举到了第几个数字
* 当前分割方案


## 代码
```c++
class Solution {
public:
    vector<string> res;
    vector<string> restoreIpAddresses(string s) {
        //从第0位开始搜，当前搜第0个数
        dfs(s, 0, 0, "");
        return res;
    }

    void dfs(string& s, int u, int k, string path) {
        //如果已经搜完了所有位
        if (u == s.size()) {
            //判断当前是不是刚好有4个数
            if (k == 4) {
                path.pop_back();//将最后一个点去掉
                res.push_back(path);
            }
            return;
        }
        //如果当前数的个数已经为4了，但是还没有结束
        if (k == 4) return;

        //开始搜索当前第k个数，第k个数从第u位开始
        //t表示当前这个数值为多少
        for (int i = u, t = 0; i < s.size(); i ++) {
            //如果至少有两位，且s[u]为0，则表示有前导0
            if (i > u && s[u] == '0') break;
            //更新当前数
            t = t * 10 + s[i] - '0';
            if (t <= 255) dfs(s, i + 1, k + 1, path + to_string(t) + '.');
            else break;
        }
    }
};
```