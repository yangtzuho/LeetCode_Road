# 55：跳跃游戏
来源：[力扣（LeetCode)](https://leetcode.cn/problems/jump-game/)

* 难度：中等

## 题目描述
给定一个非负整数数组 nums ，你最初位于数组的**第一个下标**。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。
## 样例：
##### 示例 1：
```
输入：nums = [2,3,1,1,4]
输出：true

解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```
##### 示例 2：
```
输入：nums = [3,2,1,0,4]
输出：false

解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

**提示：**
* 1 <= nums.length <= 3 * 10000
* 0 <= nums[i] <= 100000
## 思路
* 能够跳到的位置一定是前面某个连续的一段，否则一定能找到两个相邻的点，前面一个点不能跳到，后面一个点能够跳到，则后面一个点一定是从前面某个位置跳过来的，那么那个位置少跳一格就可以跳到前面那个位置，矛盾。因此结论正确
* 从前往后扫描，记录当前能够跳到的最右边的位置是什么，即i + nums[i], 如果遍历到某个点发现前面能够跳到的最远位置都到不了该位置，则返回false。
## 代码
```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        //从前往后扫描，j表示能够跳到的最靠右的位置
        for (int i = 0, j = 0; i < nums.size(); i ++) {
            //如果能跳到最右边的位置小于i
            if (j < i) return false;
            j = max(i + nums[i], j);
        }
        return true;
    }
};
```